## 4. 표현식과 연산자
표현식이란?  <strong>자바스크립트 인터프리터가 값(value)로 평가하는 자바스크립트 구문</strong> 
- 간단한 표현식(기본표현식) : 임의의 상수, 변수에 할당된 임의의 값
- 복잡한 표현식(복합표현식) : 기본표현식이 결합된 표현식의 형태
ex) 배열접근 표현식은 `[`(열린대괄호) + 숫자로 평가되는 표현식 +`]`(닫힌대괄호) 가 결합된 형태
ex) 함수호출 표현식은 함수객체 + 인자표현식이 결합된 형태


### 4-1. 기본 표현식
가장 기본적인 형태로서 다른 표현식을 포함하지 않는 독립적 표현식.
상수, 리터럴 값, 특정 키워드들, 변수 참조가 이에 해당한다.

- 리터럴
```js
1.23 //숫자 리터럴
"hello" //문자 리터럴
/pattern/ //정규표현식 리터럴
```

- 예약어
```js
true //불리언 true 값으로 평가
false //불리언 false 값으로 평가
null //null 값으로 평가
this //'현재'객체로 평가
```

- 변수참조:
자바스크립트에서는 프로그램 안에 존재하는 각 식별자들을 일단 변수라고 가정하고 값을 살펴본 뒤 해당 식별자를 이름으로 하는 변수가 없다면 해당 표현식을 undefined 라고 평가한다. 
```js
i //변수 i 의 값으로 평가
sum //변수 sum 의 값으로 평가
undefined //전역변수, null 과 달리 키워드가 아니다.
```
### 4-2. 객체와 배열의 초기화 표현식
새로 생성된 객체난 배열을 값으로 하는 표현식, '객체리터럴'과 '배열리터럴'이라고 하기도 하지만 일반리터럴과 달리 기본표현식은 아니다.
 - 배열 초기화 표현식 : 
    - 대괄호와 쉼표로 구분 
    - 배열 초기화 표현식의 값은 새로 생성된 배열
    - 생성된 배열의 원소들은 각각 쉼표로 구분된 표현식의 값들로 초기화된다
    ```js
    [] //빈배열 : 대괄호 안에 표현식이 없으면 원소가 없음
    [1+2, 3+4] // 두 개의 원소를 가진 배열
    ```
    - 원소 표현식으로 또 다른 배열 초기화 표현식을 사용할 수도 있다 = 중첩 배열이 가능하다
    ```js
    let matrix = [[1,2,3],[4,5,6],[7,8,9]]
    ```
    - 배열이 초기화될 때마다 원소표현식이 평가된다 = 평가될 때마다 원소의 값은 달라질 수 있다.
    - 쉼표 사이의 값을 생략함으로서 원소의 값을 정의하지 않을 수 있다.
    ```js
    let sparseArray = [1,,,,5] //세 개의 정의되지 않은 원소를 포함해 총 다섯개의 원소를 가지고 있다.
    ```

  - 객체 초기화 표현식 : 
    - 중괄호 사용, 각 하위 표현식 앞에는 프로퍼티의 이름과 클론(:)사용
      ```js
      let p = {x:2.3, y:-1.2} //2개의 프로퍼티를 가진 객체
      ```
    - 중첩이 가능
      ```js
      let recangle = {upperLeft : {x:2, y:2}, lowerRight : {x:1,y:5}
      ```
 	- 프로퍼티 이름으로 식별자 대신 문자열 사용이 가능
      ```js
      let side = 1
      let square = { "upperLeft" : {x: p.x, y: p.y}, "lowerRight" : {x: p.x + side, y: p.y + side}
      ```
 
 ### 4-3. 함수 정의 표현식
 - 함수 정의 표현식은 함수를 정의하고 함수 정의 표현식의 값은 새로 정의된 함수이다.
 - 일반적으로 function 키워드 + 중괄호로 둘러싸인 쉼표로 구별된 식별자(매개변수이름)목록 + 중괄호로 둘러싸인 코드(함수본체)로 이루어진다.
    ```js
  let square = function(x){ return x*x }
  ``` 
- 함수 정의 표현식은 함수 이름을 포함할 수 있으며 함수 정의 표현식 대신 함수 구문을 사용해 정의할 수 있다.(8장에서 자세히)
 
 
 ### 4-4. 프로퍼티 접근 표현식
 - 객체의 프로퍼티나 배열의 원소값으로 평가
 - 자바스크립트에서는 두가지 문법으로 프로퍼티에 접근 가능하다.
 #### 1) 표현식.식별자
   여기서 표현식은 객체이며 식별자는 앞서 지정한 객체에서 찾을 프로퍼티의 이름이다.
    
 #### 2) 표현식[표현식]
 여기서도 앞서 표현한 객체의 특정 프로퍼티 이름이나 배열 내 원소의 인덱스 값이 대괄호와 함께 사용된다.
 
   ```js
  let o ={x:1, y:{z:3}}
  let a = [o,4,[5,6]]
  o.x //1 
  o.y.z //3
  o["x"] //1
  a[0].x //1
  ```
- 두 표현식 모두 점(.)이나 대괄호 왼쪽 표현식이 먼저 평가되고 만약 평가된 값이 null이나 undefined 일 경우 프로퍼티를 갖지 않기 때문에 표현식은 TypeError 를 발생시킨다.
- 두 방법 중 .식별자 문법이 더 간단하지만 접근하려는 프로퍼티 이름이 '합법적'식별자일때만 사용할 수 있고, 식별자를 미리 알고 있어야 하며, 프로퍼티 이름이 예약어거나 공백을 포함하거나, 숫자일 경우에는 반드시 대괄호를 사용해야 한다.
 
 ### 4-5. 호출 표현식
 - 함수나 메서드를 호출하는 문법
 - 호출될 함수를 가리키는 함수표현식 + 괄호, 쉼표로 구성된 호출 인자의 목록
   ```js
  f(0) //f는 함수 표현식, 0은 인자 표현식
  Math.max(x,y,z) //Math.max는 함수, x,y,z는 호출 인자
  ```
- 호출 표현식이 평가될 때 순서 : 함수표현식 평가(함수표현식의 값이 호출할 수 없는 객체일 경우 TypeError 발생) 
-> 호출인자 표현식이 순서대로 평가 -> 함수 선언 시 지정했던 인자 이름에 인자 값이 차례로 할당 -> 함수 본문 실행

  <table>
    <thead><th></th><th>단독으로 사용</th><th>다른 식별자와 사용</th></thead>
    <tbody><td>식별자 뒤에 괄호 O</td><td>변수</td><td>프로퍼티</td></tbody>
    <tbody><td>식별자 뒤에 괄호 X</td><td>함수</td><td>메소드</td></tbody>
  </table>

```js
alert('aaa') //alert은 함수
Array.length //length는 프로퍼티
input //input은 변수
Math.abs(-200)//abs는 메서드
```
 
 ### 4-6. 객체 생성 표현식
- 새 객체를 생성하고, 생성자라고 부르는 함수를 호출해 객체에 속한 프로퍼티들을 초기화
 - new 키워드가 앞에 붙는다는 점을 제외하면 호출 표현식과 유사하다.
 
    ```js
    new Object()
    new Point(2,3)
    ```
 - 객체의 생성자 함수를 인자 없이 호출할때는 괄호를 생략할 수 있다.

  ```js
  new Object
  new Date
  ``` 
  
### 4-7. 연산자 개요
- 연산자는 수식표현식, 비교표현식, 논리표현식, 할당표현식 등 다양하게 사용됨
- 대부분의 연산자는 부호이지만 delete, instanceof 와 같은 키워드도 표현되기도 함
  #### 4.7.1 피연산자 개수
   - 대부분은 곱셈연산자처럼 2항 연산자(2개의 표현식의 결합)
   - -x처럼 피연산자 x의 부호를 전환하는 단항연산자
   - 조건부 연산자인 ? : 는 3항 연산자
  #### 4.7.2 피연산자와 반환 타입
  - 대부분의 경우 피연산자 타입이 정해져 있으며 특정 타입의 값을 반환(또는 평가)한다.
  - 자바스크립트는 필요할 때마다 피연산자 타입을 변환한다. (3.8절 참고) 
  - 모든 값은 참이나 거짓으로 평가되므로 불리언 값을 피연산자로 갖는 연산자는 어느 상황에도 문제없이 동작한다.
  - 일부 연산자들은 피연산자의 타입에 따라 다르게 작동한다. +연산자는 피연산자가 숫자타입이면 덧셈을 하지만, 문자열 타입이면 문자열을 이어붙인다.
  #### 4.7.3 좌변 값
  - 할당 연산자를 비롯한 몇가지 연산자의 피연산자 타입은 좌변값이다. (++, --)
  - 할당 표현식의 좌변에 나타날 수 있는 표현식에서 유래한 용어
  - 변수, 객체 프로퍼티, 배열 원소가 좌변 값
  #### 4.7.4 연산자 부수 효과
  - 2*3 과 같은 간단한 표현식의 평과 결과는 프로그램 상태에 영향을 끼치지 않으나 일부 표현식은 부수효과를 갖는다.
  - 할당 연산자가 대표적
  - 변수나 객체의 프로퍼티에 값을 할당하면 이를 사용하는 모든 표현식의 값이 바뀌는 것
  - 유사하게 ++, --도 실행되면 기존의 값을 변경하는 묵시적 할당이 이루어진다.
  #### 4.7.5 연산자 우선순위
  - 사칙연산 : 일반적인 사칙연산과 같은 원칙(*,/이 +,-보다 먼저 수행되며 괄호 사용 가능)
  - 프로퍼티 접근이나 호출 표현식은 연산자들보다 항상 우선순위가 높다.
  ```js
  typeof my.function[x](y) //프로퍼티 접근과 함수 호출이 끝난 후 typeof 연산자가 실행된다.
  ```
  #### 4.7.6 연산자 결합 방향 
  - 각각 연산자마다 지정된 왼->오 / 오->왼 결합방향이 있으며 이는 우선순위 연산들 간의 수행순서를 의미
  #### 4.7.7. 평가 순서
  - 연산자 우선선위와 결합방향이 어떤 연산이 우선 수행될지를 결정하지만 어떤 부 표현식이 번저 평가되는지를 결정하지는 않는다.
  ```js
  w=x+y*z 
  //부 표현식 w가 먼저 평가된 후 x,y,z, 가 차례대로 평가, 
그 후 y*z, +x 를 하여 w 가 가리키는 변수난 객체 프로퍼티에 값을 할당. 
표현식에 괄호를 추가하여 순서를 변경할 수는 있지만 왼쪽에서 오른쪽으로의 평가순서는 바꿀 수 없다.

  ```

### 4.8 산술 표현식
- 기본 산술 연산자 *(곱셈),/(나눗셈),%(나머지), +(덧셈), -(뺄셈)
- 덧셈연산자를 제외한 산술연산자들은 단순히 피연산자를 평가, 값을 숫자로 변환한 후 연산을 수행
- 숫자로 변환 불가능한 피연산자는 NaN으로 변환, 피연산자 중 하나라도 NaN이면 결과도 NaN

#### 4.8.1 덧셈연산자+
- 덧셈연산자가 이항연산자로 사용될 때는 숫자값을 더하거나 피연산자 문자열을 이어붙인다.
- 두 피연산자 모두 값이 숫자거나 문자일 때를 제외한 경우에는 타입 변환이 먼저 이루어진다.
- 하나의 피연산자 값이 객체일 경우 객체를 원시타입으로 바꾼뒤 이어붙인다.
- 피연산자가 객체에서 원시타입으로 변환된 후, 만일 어떤 피연산자라도 문자열이면, 다른 피연산자를 문자열로 변환한 후 이어붙인다.
- 이외의 경우에는 피연산자가 숫자 혹은 NaN으로 변환된 후 덧셈연산이 수행된다.
  ``` js
  1+{?} //"1[object Object]" :객체를 문자열로 바꾼 뒤 이어붙이기
  true + true // 2 : 불리언 값을 숫자로 바꾼 후 더하기
  2 + null //2 null 값을 0으로 바꾼 후 더하기
  2 + undefined // NaN : undefined를 NaN 으로 바꾼 후 더하기
  ```
- 여러 문자열과 여러 숫자를 함께 사용할 때에는 결과가 달라질 수 있다.
  ```js
  1 + 2 + "blind mice" = '3 blind mice'
  1 + (2 + "blind mice") = '12 blind mice'
  ```
#### 4.8.2 단항 산술 연산자
- 하나의 피연산자 값을 수정하여 새 값으로 만듬
- 자바스크립트에서 가장 우선순위가 높으며 결합방형은 오->왼
- 느낌표(!)문자와 +,=는 단항과 이항 양쪽으로 사용 : 
    - 단항덧셈(+) : 피연산자를 숫자 혹은 NaN 으로 바꾼 후 값 반환
    - 단항뺄셈(-) : 피연산자를 가능하면 숫자로 변환하려 시도
    - 증가(++) : 단항 피연산자에 대해 증가연산(1을 더한다). 감소(--)도 이와 동일하다.
    이때 피연산자는 반드시 좌변값(변수,배열원소 혹은 객체 프로퍼티)이어야 한다. 좌변값이 숫자가 아닐 경우 일단 숫자타입으로 변환후 1을 더한다.
    - 피연산자의 어느쪽에 연산자가 위치하느냐에 따라 전치증가, 후치증가로 연산 후 내놓는 값이 다르다.
    ```js
    let i =1, j = ++i //i와 j a모두 2
    let i =1, j = i++ //i는 2이고, j는 1
    ```
#### 4.8.3 비트 단위 연산자
- 2진수를 저수준에서 조작하는데 사용하나 일반적으로는 사용되지 않음
- skip

### 4.9 관계형 표현식
- 두 피연산자 값의 관계를 검사하여 true, false 를 반환
#### 4.9.1 동치와 부동치 연산자
- ==(동등) 와 ===(일치 : 엄격한 동치) / != 와 !==
- ==는 상대적으로 규칙이 엄격하지 않아, 두 피연산자의 타입이 다를 경우 타입변환을 시도한 후 다시 비교
    ```js
  "1"==true //true
  ```
- 자바스크립트는 값 비교가 아닌 참조비교이므로 객체는 자기 자신과는 같으나 다른 객체와는 같지 않다. (배열도 마찬가지)
- NaN 은 자기 자신을 포함해 어떤 것과도 일치하지 않으므로 피연산자 중 하나가 NaN 인경우 두 값은 일치하지 않는다.
#### 4.9.2 비교 연산자(<,<=, >,>=)
- 두 피연산자 값의 상대적인 순서를 판단할때 사용
- 피연산자 타입의 제한이 없으나 숫자와 문자열만 비교가능하므로 이에 해당하지 않을 경우 먼저 변환된다.
- 변환 후 모두 문자열인 경우 알파벳 순서로 문자열을 비교한다.
- 문자열 비교는 유니코드의 비교이며 대소문자를 구분한다.
- 피연산자나 변환된 피연산자 중 NaN 이 있으면 false 를 리턴한다.
#### 4.9.3 in 연산자
- in을 기준으로 좌변의 피연산자로 문자열을 받고 우변의 피연산자로 객체나 배열을 받는다. 
- 좌변값이 우변 객체의 프로퍼티 이름에 해당할 경우 true
  ```js
  let point ={x:1, y:1}
  "x" in point //true 
  let date =[7,8,9]
  "0" in data //true : 배열에 0번째 원소가 있음
  3 in data //false : 배열에 3번째 원소가 없음
  ```
#### 4.9.4 instanceof 연산자
- 좌변 피연산자로 객체, 우변 피연산자로 객체 클래스의 이름을 식별자로 받는다.
- 좌변 객체가 우변 클래스의 인스턴스인지에 따라 true/false 를 반환한다.
  ```js
  let v = new Date();//Date()생성자로 새로운 객체를 생성
   d instanceof Date //true : d는 Date()에 의해 생성됨
   d instancdof Object // true : 모든 객체는 Object의 인스턴스
   let a =[1,2,3] //배열 리터럴 문법으로 새로운 배열을 생성
   a instanceof Array //true : a는 배열이다
   a instaceof Object  //treu : 모든 배열은 객체다
  ```
### 4.10 논리 표현식
-논리연산자 ||, &&, ! 는 불리언 대수를 수행한다.
#### 4.10.1  논리 AND(&&)
- 두 피연산자가 모두 true 일 경우에만 true 를 반환
- 모든 자바스크립트 값은 불리언으로 평가될 수 있으므로 &&의 피연산자가 반드시 불리언 값이 올 필요는 없다.
- false 로 평가되는 값은 false, null, undefined, 0, -0, NaN, ""(빈문자열)
- 이외에는 모두 true
- 좌변 표현식을 먼저 평가하는데 이때 좌변의 값이 flasy면 우변의 표현식을 평가하지 않는다.(단축평가)
  ```js
  if(a===b) stop() //a===b를 만족할 때만 stop()함수를 호출
  (a===b) && stop() //위와 같이 동작한다.
  ```
#### 4.10.2 논리 OR(||)
- 불리언 Or 을 수행
- 좌변의 값이 false 로 평가되면 전체 표현식은 바로 그 값이 되고, 좌변의 값이 true 로 평가되면 두번째 피연산자의 값이 표현식의 값으로 반환된다.
- 다음의 코드는 여러 값 중에 최초로 true로 평가되는 값을 선택하는 경우 사용된다.
  ```js
    let max = max_width ||preference.max_width ||500 
    //max_width가 정의되어 있으면 사용하고, 없으면 preference 객체의 속성을 찾아보고, 거기에도 없으면 하드코딩된 상수를 사용한다. 
  ```

#### 4.10.3 논리 NOT(!)
- !는 단항연산자로 단일 피연산자 앞에 놓인다.
- 피연산자의 불리언 값을 반대로 바꾼다. 
- 피연산자 값을 불리언 값으로 변환한 후 값을 반전한다.
- 단항연산자이므로 결합된 표현식을의 전체를 반전시키고 싶다면 괄호를 사용해야한다.  !(p && q) === !p || !q
		
### 4.11 할당 표현식
- 자바스크립트에서는 = 연산자를 사용해 변수나 프로퍼티에 값을 할당한다.
  ```js
  i =0 //변수 i 의 값을 0으로 설정
  o.x = 1 //객체 o의 프로퍼티 x 의 값을 1로 설정
  ```
- 좌변에는 좌변값(변수, 객체프로퍼티, 배열의 원소)이, 우변에는 타입에 상관없이 어떤 값이라도 올 수 있다.
- 여러개를 할당할 경우에는 아래와 같이 작성한다.
  ```js
  i=j=k=0//세 변수의 값을 0으로 초기화한다
  ```
  
#### 4.11.1 연산을 동반하는 할당
- 일반적인 = 할당연산자 이외에도 다수의 할당 연산자가 있다.
  - += , =+, *=, /= , %=, <<=, >>=, >>>=, &=, |=, ^= 
- += 연산자는 덧셈과 할당을 함께 수행한다.
  ```js
  total += sales_tax 
  total = total + sales_tax // 두 식은 같다.
  ```
### 4.12 평가 표현식
- 자바스크립트는 문자열을 자바스크립트 코드로 해석하고 평가한 값을 값으로 출력할 수 있는데 전역함수 eval()이 이를 수행한다.
  ```js
  eval("3"+"2") //5
  ```
- 매우 강력한 기능이지만 실제로는 거의 사용되지 않는다. 

### 4.13 기타 연산자들
#### 4.13.1 조건부 연산자(?:)
- 자바스크립트의 유일한 3항 연산자
- 피연산자로 어떤 타입도 올 수 있으며 첫번째 피연산자는 불리언 값으로 평가
  - 첫번째 피연산자가 true로 평가되면 두번째 피연산자가 평가되고 값이 반환
  - 첫번째 피연산자가 false 로 평가되면 세번째 피연산자가 평가되고 값이 반환
- if 문과 비슷한 결과를 얻을 수 있지만 좀 더 간결	
  ```js
  greeting = "hello" + (username? username : "there");
  ```
#### 4.13.2 typeof 연산자
- 단일 피연산자 앞에 위치하는 단항 연산자, 어떤 타입도 가능
- 함수를 제외한 모든 객체와 배열을 object로 평가
  ```js
  typeof 함수 = "function"
  typeof null = "object"
  typeof 숫자 혹은 NaN = "number" 등을 반환
  ```
- 피연산자를 괄호로 둘러싸서 사용할 수 도 있다.
  ```js
   typeof(i)  
  ```
#### 4.13.3 delete 연산자
- 단항연산자로서 피연산자로 지정된 객체프로퍼티, 배열의 원소 또는 변수의 삭제를 시도한다.
- 보통 반환값이 아닌 부수효과(프로퍼티 삭제)를 위해서 사용한다.
  ```js
  let o = {x:1, y:2}
  delete o.x; // 객체 프로퍼티 중 하나를 삭제하고, 성공적으로 삭제했을 경우 true 를 반환
  "x" in o // false : 삭제한 프로퍼티는 존재하지 않는다.
 //존재하지 않는 프로퍼티에 접근하려고 해도 undefined 가 반환되므로 존재여부를 알려면 in 연산자를 사용한다.
  ```
- 내장 코어 프로퍼티, 클라이언트 측 프로퍼티, var, const, let으로 선언한 사용자 정의 변수, function 으로 정의한 함수는 삭제할 수 없다.

#### 4.13.4 void 연산자
- 단항연산자로 어떠한 타입도 void의 피연산자가 될 수 있다.
- 피연산자를 무시하고 undefined 를 반환
- 사용빈도가 낮다. 

#### 4.13.5 쉼표(,)연산자
- 이항연산자로, 피연산자들은 어떤 타입도 가능
- 왼쪽의 전달인자를 평가하고 오른쪽의 전달인자를 평가한 후, 오른쪽 전달인자의 값을 반환
  ```js
  i=0, j=1, k=2 //2로 평가되면 아래 코드와 동일하다
  i=0; j=1; k=2;
  ```
- 왼편의 표현식은 항상 평가되지만 값은 무시된다. 
- 쉼표 연산자가 보편적으로 쓰이는 유일한 지점은 for 문의 루프 변수 선언부이다.
  ```js
  for(let i=0,j=10; i<j; i++,j--)
  ```
  
  
## 5.문장
- 4장에서의 표현식이 자바스크립트의 구절(phrase)라면, 비슷한 의미로 문장(statement)는 명령을 말한다.
- 표현식이 어떤 값을 생성하기 위해서 평가되는 것이라면, 구문은 일을 하기 위해 실행하는 부분
- 자바스크립트는 순서대로 실행되는 문장들의 집합
- 문장의 실행 순서를 바꿈으로서 자바스크립트 인터프리터를 제어할 수 있는데 이를 수행하는 몇 가지의 문장이 존재한다.
    - if, switch 같은 조건문은 표현식의 값에 따라 다른 문장의 실행 여부를 결정할 수 있게 한다.
    - while, for 문과 같은 순환문은 특정 문장들을 반복 실행하게 한다.
    - break, return, throw 같은 도약문은 특정 부분으로 건너뛰게 한다.
    
### 5.1 표현문
- 가장 단순한 형태의 부수 효과가 있는 표현문으로 할당문이 이러한 표현문 중 하나이다.
  ```js
  greeting = "hello" + name;
  counter++; //증감 연산자들은 변수 값 자체를 바꾸는 부수 효과가 있는데 마치 변수에 값을 할당한 것과 같은 효과
  ```
- 표현문의 다른 종류로는 함수 호출이 있다. 
```js
alert(greeting);
window.Close();
//위와 같은 클라이언트 측 함수 호출은 표현식이지만 웹브라우저에 영향을 주는 부수효과가 있다.

```
### 5.2 복합문과 빈 문장
- 중괄호로 감싸는 문장 블록은 여러 문장을 하나의 복합문으로 묶을 수 있다.
- 따라서 아래의 코드는 단일 문장과 마찬가지로 취급된다.
  ```js
  {
      x = Math.PI;
      cx = Math.cos(x);
      console.log("cos(𝝿)=" + cx);
  }
  ```
- 문장블록은 내부의 기본문장들은 세미콜론으로 끝나지만 문장블록 자체는 세미클론으로 끝나지 않는다.    
- 필수는 아니지만 내부의 문장들은 들여쓰기를 해주는 것이 좋다.     
- 자바스크립트 문법에서 하나의 문장이 있어야 할 곳에 여러 문장을 사용할 수 있게 해준다.


- 이와 반대인 빈 문장은 하나의 문장이 있어야 할 곳에 아무런 문장도 두지 않을 수 있도록 한다.
  ```js
  ; //빈문장
  ```
- 자바스크립트 인터프리터는 빈문장을 만나면 아무것도 실행하지 않는다. 몸체가 비어있는 루프를 만들때 유용하다
  ```js
  for(i=0;i<a.length;a[i++]=0); //배열 a를 초기화한다.
  ```
- for, while 루프 또는 if문이 끝나는 오른쪽 괄호 다음에 의도치 않은 세미콜론을 넣는 경우 버그가 발생할 수도 있다.
  ```js
  if((a==0)||(b==0)) ; //조건과 무관하게 아무 것도 실행하지 않는다.
      a =null; // 이 행은 항상 실행된다.
  ```
  
### 5.3 선언문
- var(let,const), function 는 각각 변수와 함수를 선언하고 정의하는 선언문이다.
#### 5.3.1 var
- var 문은 하나 또는 그 이상의 변수를 선언한다. 
  ```js
  var i; //하나의 변수를 선언, i 의 값은 undefined
  var j=0; //하나의 변수와 값을 선언
  var p, q //두 변수를 선언
  ```
- 함수 내부에서 사용한 var 문은 지역변수, 해당 함수 내에서만 사용 가능
- 변수에 초기값을 지정하지 않으면 undefined

#### 5.3.2 function
- function 키워드는 함수를 정의하는데 쓰인다.
  ```js
  let f = function(x){return x+1} //변수에 함수를 할당하는 표현식
  function f(x){return x+1} //변수 이름을 포함한 문장
  ```
- 함수 몸체는 중괄호와 내부의 문장들로 구성되며 이 문장들은 함수가 정의될 때는 실행되지 않는다.
- 함수가 호출되면 실행될 수 있도록 새로운 함수 객체와 연결된다.
- 함수선언문은 자바스크립트 최상위 단계에서도, 다른 함수 내에서도 나타날 수 있다.
- 중첩될 때에는 중첩된 함수 내에서 최상위 단계에 위치해야 한다. = if문이나 while 문 같은 다른 문장 안에 있을 수 없다.

### 5.4 조건문
- 특정 표현식의 값에 따라 문장을 실행하거나 건너뛰는데 이를 '분기'라 한다.
#### 5.4.1 if
   ```js
    if(표현식)
      문장
      //이러한 형태에서 표현식의 값이  true 이면 문장이 실행되고, false 이면 실행되지 않는다.
    
    if(표현식)
      문장1
    else
      문장2
     //위와 동일하나 표현식이 false 경우 문장2가 실행된다.  
   ```
- else 가 어느 if문에 속했는지 알기 위해서, 유지보수를 위해서 중괄호를 사용한다.

#### 5.4.2 else if
- else if는 자바스크립트 고유의 구문은 아니나 if/else 문을 반복해서 사용하던 것이 관습으로 굳어져 널리 쓰이게 되었다.
#### 5.4.3 switch
- switch 문은 if 문에서 동일한 표현식이 여러번 반복되는 문제점을 해결할 수 있다. 
  ```js
  switch(표현식){
      문장들
  }
  ```
- 스위치문의 case 절은 오직 실행하려는 코드의 시작지점만 결정한다.
- break문이 없으면 해당 case 에서 시작해 블록 끝까지 계속 실행하므로 break 문으로 코드 실행을 중지할 수 있다.
- switch 키워드 다음에 나오는 표현식을 평가한 후, 대응하는 값을 찾을때까지 순서대로 case 문을 평가한다.
- case 를 판별할때는 엄격한 동치(===)를 사용한다.

  ```js
  switch(n){
    case 1 : //n ===1 이면 여기서 시작
      break;  //여기서 멈춘다
    case 2 : //n===2 이면 여기서 시작
      break; //여기서 멈춘다
    default: //모든 경우에 해당하지 않으면 여기서 시작
      break; //여기서 멈춘다
  ```  
### 5.5 루프
- 루프문은 분기 경로에서 일정부분의 코드를 실행한 후, 다시 해당 분기 경로로 되돌아간다.
- 자바스크립트의 루프문은 while, do/while, for, for/in 네 가지가 있다.
#### 5.5.1 while
- 표현식을 먼저 평가하는데, 값이 true 이면 문장을 실행한 후, 표현식을 다시 평가한다.
- 표현식이 false 로 평가될때까지 루프의 몸체를 반복 실행한다.
  ```js
  while(표현식)
    문장

  let count =0;
  while (count<10){
    console.log(count);
    count++;
  }
  ```
#### 5.5.2 do/while
- 표현식이 테스트되는 시점이 루프의 처음이 아니라 마지막이라는 점을 제외하면 while 문과 유사하다.
  ```js
  do
    문장
  while(표현식)
    
  function printArray(a){
    let len = a.length, i=0;
    if(len ==0)
      console.log("empty array");
    else {
      do {
        console.log(a[i]);
      } while (++i <len);
    }
  }
  ```
#### 5.5.3 for
- for 문의 특정 패턴을 사용하면 while 문보다 편리하게 루프를 만들 수 있다. 
- 초기화, 테스트, 증감은 세미클론으로 구분된 세 가지 표현식이다.
- 루프가 시작되기 전에 초기화 표현식이 한 번 평가된다.

  ```js
  for(초기화 ; 테스트 ; 증감)
    문장 
  
  //위 for문은 아래의 while문과 동일하다고 볼 수 있다.
  초기화;
  while(테스트){
    문장
    증감;
  }

  for(let count=0; count<10; count++)
  	console.log(count);
  //앞서 while 문에서 나온 예문과 동일한 결과를 산출한다. 
  ```
- 테스트 표현식은 매회 반복이 일어나기 직전에 평가되며, 루프 몸체 실행여부를 제어한다.
- 루프 변수가 반드시 숫자형일 필요는 없다. 
- 앞서 나온 쉽표 연산자가 널리 쓰인다.
- 아래의 예에서는 초기화 표현식이 생략되었는데, 세 표현식 중 어느 식이든 생략될 수 있지만 두 개의 세미콜론은 꼭 필요하다.

  ```js
function tail(o) { //링크드 리스트 마지막 객체 o를 반환한다.
   for(; o.next; o=o.next) ; //쉼표연산자, 아무일도 일어나지 않는다
   return o 
  ```
  
#### 5.5.4 for/in
- for문을 사용하지만 일반적인 for문과는 다르다.
  ```js
for (변수 in 객체)
      문장
  ```
  ```js
//일반적인 for loop을 이용해 배열의 원소를 순회할 수 있다.
for(let i =0;i<a.length;i++) //변수 i에 배열의 인덱스를 할당한다
  console.log(a[i]) //각 배열 원소 값을 출력한다

  //이와 비슷하게 for/in loop 을 사용해 객체가 가진 프로퍼티들을 순회할 수 있다.
const o = {x:1, y:2, z: 3}
for(let p in o) //변수 p에 객체 o가 가진 프로퍼티 이름을 할당한다
    console.log(o[p]) //1,2,3 : 객체 o가 가진 각 프로퍼티의 값을 출력한다
  ```
- ECMAScript 명세는 for/in 루프가 객체의 프로퍼티들을 열거하는 순서는 명시하지 않고 있지만 대부분 브라우저에서 프로퍼티들이 정의된 순서대로 열거하고 있다.


### 5.6 점프문
- 이름 그대로 인터프리터가 점프문을 만나면 소스 내 특정 위치로 건너뛴다.
#### 5.6.1 레이블
- 어떤 문장에 식별자 이름과 클론(:)을 넣으므로써 레이블을 붙일 수 있다.
- 레이블을 붙이면 다른 곳에서 문장을 참고 할 수 있어 유용하다.
- 예약어를 제외한 모든 적법한 자바스크립트의 식별자는 레이블이 될 수 있다.
  ```js
 mainloop : while(token!=null){
   //코드 생략
   continue mainloop; //주어진 mainloop의 다음 반복으로 건너뛴다.
   //코드 생략
 }
  ```
#### 5.6.2 break
- break문을 만나면 이를 감싸고 있는 가장 안쪽의 루프 혹은 switch문에서 즉시 빠져나온다.
- break문은 오직 루프나 switch 문 내부에서만 적법하다.

#### 5.6.3 continue
- break 문과 유사하나 루프를 빠져나오지 않고 새로운 반복을 시작한다는 점이 다르다.
- 루프 내부가 아닌 다른 부분에 사용하면 문법 에러가 발생한다.
- while 루프 내부에서 continue문이 실행되면 루프의 시작 부분에 지정된 표현식을 다시 테스트한다. 
결과가 true 이면 루프 몸체 처음부터 다시 실행을 시작한다.
- for 내부에서는 증감 표현식을 평가한 후, 테스트 표현식을 테스트하여 다음 반복을 수행할지 결정한다.

#### 5.6.4 return
- 함수 호출 표현식의 값,즉 함수에서 반환하는 값을 지정하는데 쓰인다.
- return 문은 오직 함수 내부에서만 나타날 수 있고, 다른곳에서 쓰이면 문법 에러가 발생한다.
- return 문이 실행되면 표현식이 평가되어 그 결과가 함수의 값으로 반환된다
  ```js
  return 표현식;  //작성방법, 자바스크립트의 자동 세미콜론 삽입 기능 때문에return 과 표현식 사이에 줄바꿈을 하면 안된다.

  function square(x){return x*x} //return 문을 가지고 있는 함수
  square(2) //이 호출은 4로 평가된다
  ```
- 함수 내에 return 문이 없다면 함수 호출은 함수 내부의 구문을 차례로 실행하고 호출한 지점으로 돌아간다.
- 함수 내에 return 문이 없는 경우 해당 함수 호출 표현식의 값은 undefined 가 된다.
- 함수 내부에서 return 문이 실행되면 아직 남은 문장들이 있더라도 함수를 호출한 지점으로 돌아간다.

#### 5.6.5 throw
- 예외를 발생시키는 것(throw)은 에러나 예외상황을 알린다는 의미이고, 이를 잡아내는(catch)는 것은 예외를 처리한다는 것이다.
- 자바스크립트에서는 런타임 에러가 일어날 때마다 예외를 발생시킨다. 
- 이러한 예외는 try/catch/finally 문을 사용해 처리할 수 있다.
    ```js
    throw 표현식 ; //작성방법
    ```
- 표현식은 어떤 자료형의 값으로도 평가될 수 있으므로 숫자/문자열을 던질 수 있다.
- Error 객체는 에러의 종류를 담고있는 name 프로퍼티와 message 프로퍼티를 갖고 있다.
- 예외가 발생할 경우 자바스크립트 인터프리터는 프로그램 실행을 즉시 중단하고 가까운 catch 절로 작성된 예외 처리기로 넘어간다.
예외처리기를 찾을 수 없다면 해당 예외는 에러로 취급되어 사용자에게 보고된다.

#### 5.6.6 try/catch/finally
- try절은 예외가 발생할지도 모르는 코드 블록을 정의하는 역할을 한다.
- catch 절은 try 절 이후에 오며, try 블록 내부에서 예외가 발생할 경우 호출되는 문장 블록이다.
- finally 절은 catch 절 다음에 오며 try 블록에서 일어난 일에 관계없이 실행된다. 뒷정리용 코드
- catch 나 finally 블록은 생략이 가능하나 try 블록이 사용되었다면 catch/finally 중 하나 이상이 함께 사용되어야 한다.
    ```js
  try{
    //코드생략
  }
  catch(e){
    //코드생략
  }
    ```
- 예외가 발생하면 Error 객체와 같이 예외와 관련된 값이 catch 키워드 다음에 오는 괄호 안의 식별자에 할당된다.
- 만일 try 블록에서 예외가 발생했는데 예외처리용 catch 블록이 있다면 catch블록으로 이동한 후에 finally 블록으로 이동한다.

### 5.7 기타
#### 5.7.1 with
- with 문은 유효범위 체인(변수의 이름을 찾기 위해 순서대로 검색되는 객체 리스트)을 임시로 확장할 때 쓰인다.
- with 문은 유효범위 체인의 첫번째에 객체를 추가한 후, 문장을 실행한 후 유효범위 체인을 원상태로 돌려놓는다.
  ```js
with(객체)
  문장 //문법
  ```
- with 문을 사용하는 자바스크립트 코드는 최적화하기 힘들고 속도도 현저히 느리다.
- with 문은 strict 모드에서는 사용할 수 없고, 비엄격 모드에서도 사용하지 않는 것이 좋다.

#### 5.7.2 debugger
- debugger 문은 평소에는 아무것도 하지 않는다.
- 디버거 프로그램을 사용할 수 있고, 디버거가 실행중일 때 코드 디버깅을 수행한다.
- debugger 문은 코드의 실행을 잠시 멈추고 디버거 프로그램을 사용해 디버깅을 진행하게 된다.
  ```js
fucntion f(o){
  if(o===undefined) debugger; //디버깅을 하기 위한 임시 코드
  ...			    //기존의 코드는 여기서부터 시작한다
  ```
#### 5.7.3 "use strict"
- ECMAScript 5에서 처음 소개
- 스크립트의 시작 부분이나 함수 몸체의 시작 부분에 올 수 있으며, 실제 실행문 앞에 오기만 하면 된다.
- 사용하는 이유는 이후에 오는 코드들이 엄격 모드를 따르게 하기 위해서다.
- 엄격모드가 실행되면 강력한 에러검사와 몇가지 언어적 문제점을 수정하며, 향상된 보안 기능을 제공한다.
    - with 문은 엄격모드에서 사용불가
    - 엄격 모드에서는 모든 변수는 반드시 선언되어야 한다. 선언되지 않은 변수, 함수, 함수의 인자, 전역 객체 프로퍼티에 값을 할당할 경우 referenceError 예외가 발생한다(표준모드에서는 묵시적으로 승인된다)
    - 메서드가 아닌 함수의 this 값은 undefined 이다. (표준모드에서는 항상 전역객체를 this의 값으로 넘겨준다)
    
## 6. 객체
- 자바스크립트의 기본 데이터 타입
- 일종의 복합체로, 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합
- '프로토타입'이라고 하는 다른 객체의 프로퍼티를 상속받는다.
- 객체의 메서드들은 일반적으로 상속받은 프로퍼티이며, 이를 '프로토타입 상속'이라고 한다. 
- 프로퍼티를 동적으로 추가/제거 가능하므로 동적 객체이지만 정적 객체를 흉내낼 수 있다.
- 자바스크립트에서 문자열, 숫자, true/false, null/undefined 를 제외한 나머지는 객체이다.
- 객체는 변경 가능하며, 값을 직접적으로 수정하지 않고 참조를 통해 조작한다.
- 네이티브 객체 :ECMAScript 명세에 정의된 객체와 그 객체의 클래스(Array, Function, Date, 정규표현식..)
- 호스트객체 : 브라우저와 같이 자바스크립트 인터프리터가 내장된 호스트 환경에 정의된 객체(HTMLElement)
- 사용자 정의 객체 : 자바스크립트 코드의 실행으로 생성된 객체
- 고유 프로퍼티 : 객체에 직접 정의된 프로퍼티
- 상속받은 프로퍼티 : 객체의 프로토타입 객체가 정의한 프로퍼티

### 6.1 객체 생성하기
#### 6.1.1 객체 리터럴
- 중괄호({})안에 이름과 값을 콜론(:)으로 구분한 순서 쌍을 쉼표로 연결한 리스트를 생성하는 것이다.
- 프로퍼티 이름은 자바스크립트 식별자 또는 문자열이 올 수 있다.
- 프로퍼티 값으로는 자바스크립트 표현식이 올 수 있다.
  ```js
  let empty = {} //빈 객체
  let point ={x:0,y:0} //두 개의 프로퍼티를 가진 객체
  ```
#### 6.1.2 new를 사용해 객체 생성하기
- new 연산자는 객체를 만들고, 초기화
- new 키워드 다음에는 반드시 함수 호출문이 와야 하며 이때 호출되는 함수를 생성자라고 한다.
- 코어 자바스크립트는 기본타입에 대한 생성자를 내장하고 있다.
  ```js
let o = new Object();
let a = new Array();
let d = new Date();
  ```
#### 6.1.3 프로토 타입
- 자바스크립트의 모든 객체는 또 다른 자바스크립트 객체인 프로토타입과 연관되어 프로토타입으로부터 프로퍼티들을 상속받는다.
- 객체 리터럴로 생성된 모든 객체는 프로토타입 객체가 같으며 Object.prototype으로 참조가 가능하다.
- new Object()객체도 {}로 생성된 객체와 마찬가지로 Object.prototype 을 상속받는다.
- new Array()로 생성된 객체는 Array.prototype을, new Date() 객체는 Date.prototype 을 상속받는다.

#### 6.1.4 Object.create()
- Object.create() 메서드는 첫번째 인자로 프로토타입 객체, 새 객체의 프로퍼티 정보를 두번째 인자로 받는다(두번째 인자 생략 가능)
  ```js
let o1 = Object.create({x:1, y:2}) //o1은 x,y 프로퍼티를 상속받는다
let o2 = Object.create(null) //o2는 프로퍼티와 메서드가 없어서 + 연산자나 toString()같은 기본적인 메소드도 사용할수없다
let o3 = Object.create(Object.prototype) //o3는 {},new Object()와 같은 객체이다
  ```
### 6.2 프로퍼티 접근 및 설정
- 프로퍼티의 값을 가져오기 외해서는 마침표(.)연산자나 대괄호([])연산자를 사용한다.
- 대괄호 연산자를 사용할 경우, 연산자 안에 문자열로 평가되는 표현식이 들어가야 한다.
#### 6.2.1 연관 배열로서의 객체
- 대괄호 연산자를 사용하여 접근하는 것은 마치 인덱스로 배열에 접근하는 형태와 유사하다.
- 이러한 형태의 배열을 연관 배열, 해시, 맵, 사전이라고도 한다.
- 타입의 제약이 느슨한 자바스크립트에서는 객체 안에 수많은 프로퍼티 생성이 가능하다. 마침표를 통해 프로퍼티에 접근할 때는 반드시 식별자로 표현해야 하는데 식별자는 직접 프로그램 안에 타이핑해 넣은 이름이므로 프로그램 실행 도중에 변경할 수 없다. 반면 []연산자를 이용할 경우 프로퍼티의 이름을 자료형인 문자열로 표현하므로 프로그램 실행 도중에 생성하고 조작이 가능하다.
  ```js
let addr = "";
for(i=0; i<4; i++){
  addr += customer["address"+i] +'/n';
}  
//이 코드는 customer 객체의 address0부터 address3까지 프로퍼티 값을 읽고 읽은 값을 addr 변수에 차례대로 이어붙인다.
  ```
#### 6.2.2 상속
- 자바스크립트 객체는 고유 프로퍼티를 갖는 동시에 해당 객체의 프로토타입 객체로부터 여러 프로퍼티를 상속받는다.
  ```js
let o = {} //o는 Object.prototype 을 상속받은 객체이며,
o.x = 1 ;// x라는 고유 프로퍼티를 갖는다
let p = inherit(o); // (inherit 함수는 프로토타입을 상속받는 함수라고 가정한다) p는 객체 o와 Object.prototype 을 상속받고,
p.y = 2; //p는 고유 프로퍼티 y를 갖는다
let q = inherit(p) // q는 객체 o,p 와 Object.prototype 을 상속받고,
q.z = 3; // 고유 프로퍼티 z를 갖는다
let s = q.toString() ;// q는 Object.prototype을 상속받았기 때문에 toStirng()사용 가능
q.x + q.y // 3 : q는 o와 p로부터 고유 프로퍼티를 상속받았다.
  ```
#### 6.2.3 프로퍼티 접근 에러
- 존재하지 않는 프로퍼티에는 접근해도 에러가 발생하지 않고 undefined로 평가된다.
- 하지만 존재하지 않는 '객체'의 프로퍼티에 접근하려고 하면 에러가 발생한다.
  ```js
let book ={title : "lion_king"}
book.subtitle //undefined :존재하지 않는 프로퍼티에 접근
book.subtitle.length //TypeError : undefined 값에는 length프로퍼티가 없다
  ```
- 위의 예제에서 book과 book.subtitle 이 객체이거나 객체와 같이 동작한다는 것을 확신하기 전까지는 book.subtitle.length 와 같은 표현식을 사용해서는 안된다.
- 이런 예외를 막기 위해서는 && 논리 연산자를 사용할 수 있다.
  ```js
let len = book && book.subtitle && book.subtitle.length
  ```
#### 6.3 프로퍼티 삭제하기
- delete 연산자는 객체의 프로퍼티를 삭제한다.
- delete 연산자는 상속받은 프로퍼티가 아닌 고유 프로퍼티만 지울 수 있다.
- 삭제에 성공하거나, 프로퍼티가 존재하지 않아서 아무 영향도 끼지지 못한 경우에는 true를 반환한다.
  ```js
delete book.author ; //true : book 객체의 author 프로퍼티가 삭제됨
delete book["title"] ; //true : book 객체의 title 프로퍼티가 삭제됨
delete book["dfdsf"] ; //true : 일치하는 프로퍼티가 없어도 true 를 반환
  ```
#### 6.4 프로퍼티 검사하기
- 주어진 이름의 프로퍼티가 있는지 검사할 때는 메서드를 이용하거나 단순히 접근할 수도 있다.
- in 연산자, hasOwnProperty(), propertyIsEnumerable() 메서드를 사용할 수 있다.
  ```js
let o ={x:1}
"x" in o; //true
"toString" in o; // true: 객체 o 에 상속받은 Object.prototype에 toString이 있음 
o.hasOwnProperty("x") //true
o.hasOwnProperty("toString") //false: hasOwnProperty()는 고유 프로퍼티만 검사한다. 상속받은 경우 false 를 반환한다
  ```
### 6.5 프로퍼티 열거하기
- 프로퍼티가 있는지 테스트하기보다 열거하고 싶을때는 for/in 루프를 사용한다.
- 열거 가능한 프로퍼티마다 for/in 루프 몸체가 실행된다.
- 상속받은 내장 메서드는 열거할 수 없으나, 사용자가 임의로 추가한 프로퍼티들은 열거할 수 있다.
  ```js
  const o = {x:1, y:2, z: 3} //열거 가능한 3개의 고유 프로퍼티
  for(p in o)
  console.log(p) //x,y,z : 열거할 수 없는 toString은 출력되지 않는다
  ```
 - Object.key() 함수를 이용하면 객체가 가진 고유 프로퍼티 중에 열거할 수 있는 프로퍼티 이름을 배열에 담아 반환한다. 
 - Object.getOwnPropertyNamse()함수는 해당 객체가 가진 모든 고유 프로퍼티의 이름을 배열로 반환한다.
   ```js
  const o = {x:1, y:2, z: 3}
  Object.keys(o) ///['x','y','z']
   Object.getOwnPropertyNames(o) ///['x','y','z']
  ```

### 6.6 프로퍼티 Getter 와 Setter
- 프로퍼티의 값은 getter/setter 메서드로 대체할 수 있다.
- 데이터프로퍼티 : 값을 저장하기 위한 프로퍼티로 일반적으로 사용하는 프로퍼티
- 접근자 프로퍼티 : 값이 없고 프로퍼티를 읽거나 쓸 때 호출하는 함수를 값 대신 지정할 수 있는 프로퍼티를 말한다. 접근자 프로퍼티의 본질은 삼수이며 이 함수는 값을 획득하고 설정하는 역할을 한다(getter/setter)
- 프로그램이 객제의 접근자 프로퍼티의 값에 접근하면 자바스크립트 엔진이 getter 메서드를 호출하고, 프로퍼티의 값을 변경하려고 하면 setter 메서드를 호출한다.
- 접근자 프로퍼티를 정의하는 방법은 확장된 객체 리터럴 문법을 사용하는 것이다.
  ```js
  let o = {
     //데이터 프로퍼티
    date_prop : value,
    //한 쌍의 함수로 정의된 접근자 프로퍼티
    get accessor_prop(){/*함수 몸체*/},
    set accessor_prop(value){/*함수 몸체*/}
  }
  ```
- 접근자 프로퍼티는 그 이름이 프로퍼티 이름과 같은 하나 또는 두 개의 함수
- function 키워드 대신 get/set을 사용하고 프로퍼티 이름 뒤에 콜론을 사용하지 않는다.

  ```js
  let user = {
    name: "John",
    surname: "Smith",

    get fullName() {
      return `${this.name} ${this.surname}`;
    }

    set fullName(value) {
      [this.name, this.surname] = value.split(" ");
    }
  };

  // 주어진 값을 사용해 set fullName이 실행
  user.fullName = "Alice Special"

  alert(user.fullName); // Alice Special
  alert(user.name); // Alice
  alert(user.surname); // Special
  ```
- 이와 같이 getter 와 setter 매서드를 구현하면 객체에 fullName 이라는 가상의 프로퍼티가 생기게 되는데, 가상의 프로퍼티는 읽고 쓸 순 있지만 실제로는 존재하지 않는다.

### 6.7 프로퍼티 속성
- 공통 속성 : 
    - Enumerable : 프로퍼티가 열거 가능한지 정하는 속성
    - Configurable : 프로퍼티의 writable, enumerable, configurable 가능 여부를 결정
     true 일 경우에는 delete 연산자를 통해 프로퍼티를 제거하거나 변경이 가능하다.
- 데이터 프로퍼티 속성 : 
    - Value : 객체에 프로퍼티를 만들면 이 속성에 값이 저장된다
    - Writable : 프로퍼티에 값을 저장할 수 있는지 여부
- 접근자 프로퍼티 속성 : 
    - Get & Set
- 이러한 프로퍼티의 속성을 질의하고 설정할 수 있도록 하는 ECMAScript 5 API 는 라이브러리를 만들때 중요하다.
(프로토타입 객체에 메서드를 추가할 수 있고, 추가된 메서드를 내장메서드처럼 열거할 수 없게 만들 수 있고, 변경하거나 삭제할 수 없는 프로퍼티를 정의하여 객체를 고정시킬 수 있기 때문)
- 접근자 프로퍼티의 네 가지 속성을 표현하기 위해 프로퍼티 디스크립터 라는 객체를 사용한다.
- 객체가 가진 특정 프로퍼티에 대한 디스크립터 객체는 Object.getOwnPropertyDescriptor()를 통해 얻을 수 있다.
  ```js
  Object.getOwnPropertyDescriptor({x:1},"x") ; //{value :1, writable : true, enumerable : true, configurable : true}
  let random ={
    get octet(){return Math.floor(Math.random()*256);
   }
  Object.getOwnPropertyDescriptor(random,"octot");//{get: /*func*/, set : undefined, enumerable : true, configurable :true}  
  ```
- 프로퍼티의 속성을 설정하거나 임의의 속성으로 새 프로퍼티를 만들기 위해서 Object.defineProperty()를 사용한다.
(인자로 수정할 객체와 추가하거나 변경할 프로퍼티 이름, 프로퍼티의 디스크립터 객체를 넘긴다.
  ```js
  let o ={} //프로퍼티가 없는 빈 객체 청의
  Object.defineProperty(o, "x", {value: 1, writable : true, enumerable : false, configurable : true});
  o.x ; //1
  Object.keys(o) // []

  Object.defineProperty(o, "x", {writable : false})
  o.x =2 //단순히 값을 변경하지 못하거나 엄격모드에서 typeError가 발생
  o.x //1

  Object.defineProperty(o,"x",{value :2}) //여전히 configurable 프로퍼티이므로 이와 같이 value를 변경할 수 있다.
  o.x //2

  Object.defineProperty(o,"x",{get:function(){return 0;}}) //프로퍼티 x를 데이터 프로퍼티에서 접근자 프로퍼티로 변경
  o.x //0
  ```

### 6.8 객체 속성
- 모든 객체는 prototype, class, extensible 속성을 가지고 있다.
#### 6.8.1 prototype 속성
- 프로퍼티를 상속하는 객체를 지정한다.
- Object.getPrototypeOf() 를 이용해 객체의 프로포타입을 검사할 수 있다.
- 객체 a가 b의 프로토타입인지 알아보기 위해서는 isPrototypeOf()메서드를 이용한다.
  ```js
  let p ={x:1}; //객체 p를 정의
  let o = Object.create(p) //객체 p를 프로토타입으로 하는 객체 o를 생성
  p.isPrototypeOf(o) //true
  ```
#### 6.8.2 class 속성
- 객체의 클래스 속성은 객체의 타입에 대한 정보를 담고 있는 문자열이다.
- 어떠한 방법으로도 이 속성을 변경할 수 없고, 그 값을 질의할 때는 toString()메서드를 이용한다.

#### 6.8.3 extensible 속성
- 객체에 새 프로퍼티를 추가할 수 있는지 여부를 결정
- 잠겨있는 객체의 상태를 고정하고, 외부에서 변경하는 것을 막기 위함이다.
- 확인하기 위해서는 Object.isExtensible() 메서드를 사용한다.
- Object.preventExtensions() 를 통해서 객체를 확장할 수 없도록 설정할 수도 있다.
- Object.seal() 메서드를 통해 객체가 가진 모든 고유 프로퍼티를 설정 불가능하게 할 수 있다.(쓰기 제외)
- Object.freeze() 메서드는 객체를 더 단단히 잠그는데, 확장불가, 프로퍼티 설정 변경 불가하게 하고 전부 읽기 전용으로 만든다.
- 위 두가지 메서드는 주어진 객체에만 영향을 주며, 객체가 가진 프로토타입 객체에는 영향을 미치지 않는다. 

### 6.9 객체 직렬화하기
- 객체의 상태를 문자열로 변환하는 과정, JSON.stringify() 메서드 사용
- 이때 생성된 문자열은 이후 객체 복원에 사용 가능 JSON.parse() 메서드 사용

### 6.10 객체 메서드
- 모든 자바스크립트 객체가 상속받는 Object.prototype 의 프로퍼티들은 대부분 메서드이다.
#### 6.10.1 toString()
- 어떠한 인자도 받지 않고, 호출 대상이 되는 객체의 값을 어떠한 방식으로든 문자열로 만들어 반환
  ```js
  const o = {x:1, y:2, z: 3}
  o.toString() //'[object, Object]'
  ```
#### 6.10.2 toLocalString()
- 객체의 지역화 된 문자열 표현을 반환

#### 6.10.3 toJSON()
- Date 객체의 문자열을 반환
  ```js
  const jsonDate = (new Date()).toJSON();
  console.log(jsonDate); //2020-10-21T19:13:27.483Z
  ```
#### 6.10.4 valueOf()
- 객체를 다를 원시 타입으로 변환하려 할 때 호출된다.
  ```js
  const stringObj = new String('foo');
  console.log(stringObj);// String { "foo" }
  console.log(stringObj.valueOf());//"foo"
  ```
